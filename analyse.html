<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="generator" content="Observable Framework v1.13.2">
<title>Analyse | Datavisualisatie</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="./_observablehq/theme-air,near-midnight.dcdbf18e.css">
<link rel="preload" as="style" href="./_observablehq/stdlib/inputs.ea9fd553.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="./_observablehq/theme-air,near-midnight.dcdbf18e.css">
<link rel="stylesheet" type="text/css" href="./_observablehq/stdlib/inputs.ea9fd553.css">
<link rel="modulepreload" href="./_observablehq/client.f780e5a8.js">
<link rel="modulepreload" href="./_observablehq/runtime.e080113b.js">
<link rel="modulepreload" href="./_observablehq/stdlib.82806664.js">
<link rel="modulepreload" href="./_observablehq/stdlib/inputs.6ba3de0b.js">
<link rel="modulepreload" href="./_npm/d3@7.9.0/e780feca.js">
<link rel="modulepreload" href="./_npm/htl@0.3.1/72f4716c.js">
<link rel="modulepreload" href="./_npm/@observablehq/plot@0.6.17/d761ef9b.js">
<link rel="modulepreload" href="./_npm/d3-dsv@3.0.1/9cffc2bd.js">
<link rel="modulepreload" href="./_npm/isoformat@0.2.1/18cbf477.js">
<link rel="modulepreload" href="./_npm/d3-array@3.2.4/e93ca09f.js">
<link rel="modulepreload" href="./_npm/d3-axis@3.0.0/0f2de24d.js">
<link rel="modulepreload" href="./_npm/d3-brush@3.0.0/65eb105b.js">
<link rel="modulepreload" href="./_npm/d3-chord@3.0.1/7ef8fb2e.js">
<link rel="modulepreload" href="./_npm/d3-color@3.1.0/aeb57b94.js">
<link rel="modulepreload" href="./_npm/d3-contour@4.0.2/1d2aed74.js">
<link rel="modulepreload" href="./_npm/d3-delaunay@6.0.4/5ced1d52.js">
<link rel="modulepreload" href="./_npm/d3-dispatch@3.0.1/9ba9c7f3.js">
<link rel="modulepreload" href="./_npm/d3-drag@3.0.0/4202580c.js">
<link rel="modulepreload" href="./_npm/d3-ease@3.0.1/cdd7e898.js">
<link rel="modulepreload" href="./_npm/d3-fetch@3.0.1/b4e2ad9a.js">
<link rel="modulepreload" href="./_npm/d3-force@3.0.0/5e804d15.js">
<link rel="modulepreload" href="./_npm/d3-format@3.1.0/86074ef6.js">
<link rel="modulepreload" href="./_npm/d3-geo@3.1.1/40599fb3.js">
<link rel="modulepreload" href="./_npm/d3-hierarchy@3.1.2/e49e792c.js">
<link rel="modulepreload" href="./_npm/d3-interpolate@3.0.1/8d1e5425.js">
<link rel="modulepreload" href="./_npm/d3-path@3.1.0/20d3f133.js">
<link rel="modulepreload" href="./_npm/d3-polygon@3.0.1/7553081f.js">
<link rel="modulepreload" href="./_npm/d3-quadtree@3.0.1/0dfd751c.js">
<link rel="modulepreload" href="./_npm/d3-random@3.0.1/3c90ee06.js">
<link rel="modulepreload" href="./_npm/d3-scale@4.0.2/843b6a76.js">
<link rel="modulepreload" href="./_npm/d3-scale-chromatic@3.1.0/ba24c2e7.js">
<link rel="modulepreload" href="./_npm/d3-selection@3.0.0/4d94e5b7.js">
<link rel="modulepreload" href="./_npm/d3-shape@3.2.0/6d3a6726.js">
<link rel="modulepreload" href="./_npm/d3-time@3.1.0/9f03c579.js">
<link rel="modulepreload" href="./_npm/d3-time-format@4.1.0/07c9626f.js">
<link rel="modulepreload" href="./_npm/d3-timer@3.0.1/b58a267d.js">
<link rel="modulepreload" href="./_npm/d3-transition@3.0.1/004da2ac.js">
<link rel="modulepreload" href="./_npm/d3-zoom@3.0.0/b5786b3f.js">
<link rel="modulepreload" href="./_npm/interval-tree-1d@1.0.4/53fe8176.js">
<link rel="modulepreload" href="./_npm/internmap@2.0.3/e08981d9.js">
<link rel="modulepreload" href="./_npm/delaunator@5.0.1/02d43215.js">
<link rel="modulepreload" href="./_npm/binary-search-bounds@2.0.5/cbf6ba23.js">
<link rel="modulepreload" href="./_npm/robust-predicates@3.0.2/aa00730b.js">
<link rel="icon" href="./_file/observable.1af93621.png" type="image/png" sizes="32x32">
<script type="module">

import {define} from "./_observablehq/client.f780e5a8.js";
import {registerFile} from "./_observablehq/stdlib.82806664.js";

registerFile("./data/data_punctualite_typedetrain_comma.csv", {"name":"./data/data_punctualite_typedetrain_comma.csv","mimeType":"text/csv","path":"./_file/data/data_punctualite_typedetrain_comma.c3c8d990.csv","lastModified":1744721234400,"size":19486});

define({id: "20c1d9be", outputs: ["Inputs","monthToSeason"], body: async () => {
const Inputs = await import("./_observablehq/stdlib/inputs.6ba3de0b.js");

function monthToSeason(date) {
  const monthIndex = (month) => {
    if ([1, 2, 12].includes(month)) return 0;
    if ([3, 4, 5].includes(month)) return 1;
    if ([6, 7, 8].includes(month)) return 2;
    return 3;
  }
  return ['Winter', 'Lente', 'Zomer', 'Herfst'][monthIndex(date.getMonth() + 1)]
}
return {Inputs,monthToSeason};
}});

define({id: "4a96907f", inputs: ["FileAttachment","monthToSeason"], outputs: ["train_data","sorted_train_data","seasonal_train_data"], body: async (FileAttachment,monthToSeason) => {
const train_data = await FileAttachment("./data/data_punctualite_typedetrain_comma.csv").csv({ typed: true });

const sorted_train_data = train_data.slice().sort(
    (a, b) => new Date(a.Month) - new Date(b.Month)
);

const seasonal_train_data = train_data.map(r => ({
    ...r,
    "season": monthToSeason(r["Month"])
}));
return {train_data,sorted_train_data,seasonal_train_data};
}});

define({id: "1888641d", inputs: ["d3","train_data"], outputs: ["trainsPerType","totalTrains","trainsPerTypeNormalized","hierarchyData","packLayout"], body: (d3,train_data) => {
const trainsPerType = d3.rollup(
    train_data,
  value => d3.sum(value, a => a["Number of operated trains"]),
  d => d["Train type"]
);

const totalTrains = d3.sum(trainsPerType.values());
const trainsPerTypeNormalized = new Map(Array.from(trainsPerType, ([key, value]) => ([key, value / totalTrains])));
const hierarchyData = d3.hierarchy({
    children: Array.from(trainsPerTypeNormalized, ([type, share]) => ({
        name: type,
        value: share
    }))
}).sum(d => d.value);

const packLayout = d3.pack()
    .size([450, 450])   // Width and height of the SVG
    .padding(5);        // Space between bubbles
return {trainsPerType,totalTrains,trainsPerTypeNormalized,hierarchyData,packLayout};
}});

define({id: "dd194582", inputs: ["packLayout","hierarchyData","d3"], outputs: ["bubbleChart"], body: (packLayout,hierarchyData,d3) => {
function bubbleChart() {
    const root = packLayout(hierarchyData);
    const svg = d3.create("svg")
        .attr("viewBox", [0, 50, 700, 300])
        .attr("style", "max-width: 100%; height: auto;");

    const color = d3.scaleOrdinal(d3.schemeCategory10);

    const node = svg.selectAll("g")
        .data(root.leaves())
        .join("g")
        .attr("transform", d => `translate(${d.y},${d.x})`);

    node.append("circle")
        .attr("r", d => d.r)
        .attr("fill", d => color(d.data.name));

// Tooltip
    node.append("title")
        .text(d => `${d.data.name}: ${(d.data.value * 100).toFixed(2)}%`);

    node.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.3em")
        .attr("font-size", d => Math.min(d.r / 3, 14))
        .text(d => d.data.name);

// === Custom Annotations ===
    const annotations = [
        {name: "INT", label: "INT", dx: -70, dy: 40},
        {name: "ICT", label: "ICT", dx: -70, dy: 40}
    ];

    for (const annotation of annotations) {
        const bubble = root.leaves().find(d => d.data.name === annotation.name);
        if (!bubble) continue;

        const {x, y} = bubble;
        const tx = x + annotation.dx;
        const ty = y + annotation.dy;

        // Line from label to bubble
        svg.append("line")
            .attr("x1", y + 4)
            .attr("y1", x - 5)
            .attr("x2", ty)
            .attr("y2", tx)
            .attr("stroke", color(annotation.name))
            .attr("stroke-width", 1);

        // Text label
        svg.append("text")
            .attr("x", ty)
            .attr("y", tx - 5)
            .attr("text-anchor", "middle")
            .attr("font-size", 10)
            .attr("fill", color(annotation.name))
            .text(`${annotation.label}: ${(bubble.data.value * 100).toFixed(2)}%`);
    }
    return svg.node();
}
return {bubbleChart};
}});

define({id: "b849ddfa", inputs: ["view","bubbleChart"], body: (view,bubbleChart) => {
view(bubbleChart());
}});

define({id: "57746480", inputs: ["train_data","view","Inputs"], outputs: ["train_types","selected_types_input"], body: (train_data,view,Inputs) => {
const train_types = Array.from(new Set(train_data.map(d => d["Train type"])));

const selected_types_input = view(Inputs.checkbox(train_types, {
    value: train_types,
    label: "Selecteer trein types om te tonen",
    sort: true
}));
return {train_types,selected_types_input};
}});

define({id: "4a6be801", inputs: ["Plot","train_types","sorted_train_data","selected_types_input","display"], body: async (Plot,train_types,sorted_train_data,selected_types_input,display) => {
display(await(
Plot.plot({
    y: { grid: true, label: "Aantal geopereerde treinen" },
    x: { type: "utc", label: "Maand" },
    color: {
        type: "categorical",
        domain: train_types,
        legend: true
        // range: ["#4682B4", "#FFA500", "#228B22", "#9370DB", "#DC143C", "#DAA520"]
    },
    marks: [
        Plot.lineY(
            sorted_train_data.filter(d => selected_types_input.includes(d["Train type"])),
            {
                x: "Month",
                y: "Number of operated trains",
                stroke: "Train type",
                marker: "circle",
                tip: true
            }
        )
    ]
})
))
}});

define({id: "a3bdb986", inputs: ["train_data","view","Inputs","train_types"], outputs: ["train_types_insights","selected_types_input_insights"], body: (train_data,view,Inputs,train_types) => {
const train_types_insights = Array.from(new Set(train_data.map(d => d["Train type"])));

const selected_types_input_insights = view(Inputs.checkbox(train_types, {
    value: train_types,
    label: "Selecteer trein types om te tonen",
    sort: true
}));
return {train_types_insights,selected_types_input_insights};
}});

define({id: "e9262dea", inputs: ["Plot","train_types_insights","sorted_train_data","selected_types_input_insights","display"], body: async (Plot,train_types_insights,sorted_train_data,selected_types_input_insights,display) => {
display(await(
Plot.plot({
    y: { grid: true, label: "Punctualiteit (%)", domain: [0, 100] },
    x: { type: "utc", label: "Maand" },
    color: {
        type: "categorical",
        domain: train_types_insights,
        legend: true,
        // range: ["#4682B4", "#FFA500", "#228B22", "#9370DB", "#DC143C", "#DAA520"]
    },
    marks: [
        Plot.lineY(
            sorted_train_data.filter(d => selected_types_input_insights.includes(d["Train type"])),
            {
                x: "Month",
                y: "Punctuality",
                stroke: "Train type",
                marker: "circle",
                tip: true
            })
    ]
})
))
}});

define({id: "f39c4b62", inputs: ["d3","seasonal_train_data","train_types"], outputs: ["seasonOrder","grouped_and_normalized_by_season","flattened","normalized","layoutMap","gridChartsData","color","row1","row2"], body: (d3,seasonal_train_data,train_types) => {
const seasonOrder = ({Winter: 0, Lente: 1, Zomer: 2, Herfst: 3});
const grouped_and_normalized_by_season = d3.rollups(seasonal_train_data,
    v => {
        const total_delay = d3.sum(v, d => d["Minutes of delay"]);
        const total_trains = d3.sum(v, d => d["Number of operated trains"]);
        return {
            "Normalized delay": total_delay / total_trains
        };
    },
    d => d["Train type"],
    d => d["season"]
);

const flattened = grouped_and_normalized_by_season.flatMap(([trainType, seasonData]) =>
    seasonData.map(([season, values]) => ({
        "Train type": trainType,
        "season": season,
        "Normalized delay": values["Normalized delay"]
    }))
);

const normalized = train_types.flatMap(type => {
    const filtered = flattened.filter(d => d["Train type"] === type);
    const total = d3.sum(filtered, d => d["Normalized delay"]);
    return filtered.map(d => ({
        ...d,
        "Normalized^2 delay": d["Normalized delay"] / total
    }));
});

const layoutMap = new Map(train_types.map((type, i) => {
    return [type, {facetRow: Math.floor(i / 3), facetCol: i % 3}]
}));

const gridChartsData = normalized.sort((a, b) => d3.ascending(seasonOrder[a["season"]], seasonOrder[b["season"]])).map(data => ({
    ...data,
    ...layoutMap.get(data["Train type"])
}));

const color = d3.scaleOrdinal()
    .domain(["Winter", "Lente", "Zomer", "Herfst"])
    .range(["#4B9CD3","#8BC34A","#FFC107","#FF5722"]);

const row1 = gridChartsData.filter(d => d["facetRow"] === 0);
const row2 = gridChartsData.filter(d => d["facetRow"] === 1);
return {seasonOrder,grouped_and_normalized_by_season,flattened,normalized,layoutMap,gridChartsData,color,row1,row2};
}});

define({id: "e60ecee4", inputs: ["row1","row2","display","html","Plot","d3","color"], body: (row1,row2,display,html,Plot,d3,color) => {
for (const row of [row1, row2]) {
    display(html`<div style="margin-bottom: 1rem; margin-top: 1rem">
    ${Plot.plot({
    facet: {
        data: row,
        x: "Train type",
        columns: 3,
        label: "Trein type"
    },
    x: {
        label: "Seizoen"
    },
    y: {
        label: "Genormaliseerde vertraging",
        domain: [0, Math.min(d3.max(row, e => e["Normalized^2 delay"]) + 0.2, 1)],
        grid: true
    },
    marks: [
        Plot.barY(
            row,
            {
                x: "season",
                y: "Normalized^2 delay",
                fill: d => color(d["season"]),
                sort: {x: "x", order: null},
                tip: true
            }),
    ],
    marginBottom: 40
    })}`);
}
}});

define({id: "230f30f6", inputs: ["seasonal_train_data","d3","seasonOrder"], outputs: ["trains","filtered_train_types","grouped_by_train_type","flattened","total_per_train_type","percentagePerSeasonAndTrainType","in_percentages","result"], body: (seasonal_train_data,d3,seasonOrder) => {
const trains = ["IC", "P", "L"];
const filtered_train_types = seasonal_train_data.filter(d => trains.includes(d["Train type"]));
const grouped_by_train_type = d3.rollups(
    filtered_train_types,
    v => ({
        total_delay: d3.sum(v, d => d["Minutes of delay"]),
        total_trains: d3.sum(v, d => d["Number of operated trains"])
    }),
    d => d["Train type"],
    d => d.season
);

const flattened = grouped_by_train_type.flatMap(([trainType, seasonData]) => {
    return seasonData.map(([season, cumulative]) => {
        const normalized = cumulative.total_delay / cumulative.total_trains;
        return {
            "Train type": trainType,
            "season": season,
            "normalized": normalized
        };
    })
});

const total_per_train_type = {};

for (const train of trains) {
    total_per_train_type[train] = d3.sum(flattened.filter(d => d["Train type"] === train), d => d["normalized"]);
}

const percentagePerSeasonAndTrainType = {};

const in_percentages = flattened.map(d => {
    const val = Math.round(d["normalized"] * 1e2 / total_per_train_type[d["Train type"]]);
    percentagePerSeasonAndTrainType[d["Train type"]] =  percentagePerSeasonAndTrainType[d["Train type"]] || {};
    percentagePerSeasonAndTrainType[d["Train type"]][d.season] = val;

    return {
        ...d,
        value: val
    };
});

// fix the the floating point errors:
for (const train of trains) {
    const row = in_percentages.filter(d => d["Train type"] === train);
    const total = d3.sum(row, d => d["value"]);
    const error = 100 - total;

    row[row.indexOf(row.reduce((prev, curr) => prev["value"] > curr["value"] ? prev : curr))]["value"] += error;
}

const result = trains.flatMap(t => {
    const rows = in_percentages.filter(d => d["Train type"] === t);
    rows.sort((a, b) => seasonOrder[a.season] < seasonOrder[b.season] ? -1 : 1);

    let units = rows.flatMap(d => {
        return Array(d["value"]).fill().map(() => {
            return {
                season: d.season,
                type: t
            }
        });
    });

    if (units.length > 100) units.length = 100;
    while (units.length < 100) units.push({season: null, type: t})
    units = units.map((d, i) => ({...d}));

    return units;
});
return {trains,filtered_train_types,grouped_by_train_type,flattened,total_per_train_type,percentagePerSeasonAndTrainType,in_percentages,result};
}});

define({id: "e59ffbf5", inputs: ["display","Plot","result","color","percentagePerSeasonAndTrainType"], body: (display,Plot,result,color,percentagePerSeasonAndTrainType) => {
display(
    Plot.plot({
        facet: {
            data:    result,
            x:       d => d.type,           // string‐accessor into each facet object
            columns: result.length,    // force one column per train type
            label:   null              // you can hide the “type” header if you like
        },
        x: { axis: null },
        y: { axis: null },
        color: {
            domain: color.domain(),
            range:  color.range(),
            legend: true
        },
        marks: [
            Plot.cell(result, Plot.stackX({
                y: (_, i) => i % 10,
                fill: "season",
                title: d => `${d.season} - ${percentagePerSeasonAndTrainType[d.type][d.season]}%`
            }))
        ]
    })
);
}});

define({id: "754c0c8f", inputs: ["train_data","view","Inputs"], outputs: ["filtered_data","delay_mode"], body: (train_data,view,Inputs) => {
const filtered_data = train_data
    .filter(d => !["ICT", "INT", "S"].includes(d["Train type"]))
    .map(d => ({
        ...d,
        "Average Delay": d["Minutes of delay"] / d["Number of operated trains"]
    }));

const delay_mode = view(Inputs.select(["Gemidelde vertraging (relatief)", "Minuten vertraging (absoluut)"], {
    label: "Kies vertoning modus",
    value: "Gemidelde vertraging (relatief)"
}));
return {filtered_data,delay_mode};
}});

define({id: "96e5af33", inputs: ["Plot","delay_mode","filtered_data","display"], body: async (Plot,delay_mode,filtered_data,display) => {
display(await(
Plot.plot({
  height: 400,
  marginLeft: 80,
  x: { label: delay_mode },
  y: { label: "Trein Type" },
  color: { legend: false },
  marks: [
    Plot.boxX(filtered_data, {
      y: "Train type",
      x: delay_mode === "Gemidelde vertraging (relatief)" ? "Average Delay" : "Minutes of delay",
      fill: "lightsteelblue"
    })
  ]
})
))
}});

define({id: "a12436e4", inputs: ["train_types","train_data"], outputs: ["included_types","cumulative_data"], body: (train_types,train_data) => {
const included_types = train_types.filter(d => !["ICT", "INT", "S"].includes(d));

const cumulative_data = (() => {
    const result = [];

    for (let type of included_types) {
        const data = train_data
            .filter(d => d["Train type"] === type)
            .sort((a, b) => new Date(a.Month) - new Date(b.Month));

        let total = 0;

        for (let d of data) {
            total += d["Minutes of delay"];
            result.push({
                Month: d.Month,
                "Train type": type,
                "Cumulative delay": total
            });
        }
    }

    return result;
})();
return {included_types,cumulative_data};
}});

define({id: "e1b8cb7c", inputs: ["Plot","included_types","cumulative_data","display"], body: async (Plot,included_types,cumulative_data,display) => {
display(await(
Plot.plot({
  marginLeft: 60,
  y: {
    grid: true,
    label: "Gecumuleerde Minuten Vertraging"
  },
  x: {
    grid: true,
    type: "utc",
    label: "Maand"
  },
  color: {
    type: "categorical",
    domain: included_types,
    range: ["#4682B4", "#FFA500", "#228B22", "#9370DB", "#DC143C", "#DAA520"],
    label: "Train type",
    legend: true
  },
  marks: [
    Plot.areaY(cumulative_data, {
      x: "Month",
      y: "Cumulative delay",
      fill: "Train type",
      tip: true
    }),
    Plot.ruleY([0])
  ]
})
))
}});

</script>
</head>
<body>
<input id="observablehq-sidebar-toggle" type="checkbox" title="Toggle sidebar">
<label id="observablehq-sidebar-backdrop" for="observablehq-sidebar-toggle"></label>
<nav id="observablehq-sidebar">
  <ol>
    <label id="observablehq-sidebar-close" for="observablehq-sidebar-toggle"></label>
    <li class="observablehq-link"><a href="./">Datavisualisatie</a></li>
  </ol>
  <ol>
    <li class="observablehq-link observablehq-link-active"><a href="./analyse">Analyse</a></li>
  </ol>
</nav>
<script>{const e=document.querySelector("#observablehq-sidebar"),o=document.querySelector("#observablehq-sidebar-toggle"),r=sessionStorage.getItem("observablehq-sidebar");r?o.checked=r==="true":o.indeterminate=!0;for(const t of document.querySelectorAll("#observablehq-sidebar summary")){const s=t.parentElement;switch(sessionStorage.getItem(`observablehq-sidebar:${t.textContent}`)){case"true":s.open=!0;break;case"false":s.classList.contains("observablehq-section-active")||(s.open=!1);break}}addEventListener("beforeunload",()=>sessionStorage.setItem("observablehq-sidebar-scrolly",`${e.scrollTop}`));const a=sessionStorage.getItem("observablehq-sidebar-scrolly");a!=null&&(e.style.cssText="overflow: hidden;",e.scrollTop=+a,e.style.cssText="");}</script>
<div id="observablehq-center">
<aside id="observablehq-toc" data-selector="h1:not(:first-of-type)[id], h2:first-child[id], :not(h1) + h2[id]">
<nav>
<div>Contents</div>
<ol>
<li class="observablehq-secondary-link"><a href="#treintypes">Treintypes</a></li>
<li class="observablehq-secondary-link"><a href="#verdere-inzichten">Verdere inzichten</a></li>
<li class="observablehq-secondary-link"><a href="#conclusie">Conclusie</a></li>
</ol>
</nav>
</aside>
<main id="observablehq-main" class="observablehq">
<h2 id="treintypes" tabindex="-1"><a class="observablehq-header-anchor" href="#treintypes">Treintypes</a></h2>
<p>Niet elke trein is hetzelfde — er zijn stoptreinen, sneltreinen, en zelfs internationale treinen. Aan de hand van hun <strong>afkortingen</strong> is het meestal eenvoudig te achterhalen met welk type je reist.</p>
<table>
<thead>
<tr>
<th>Afkorting</th>
<th>Betekenis</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IC</strong></td>
<td><strong>InterCity</strong> – stopt enkel in de belangrijkste steden.</td>
</tr>
<tr>
<td><strong>P</strong></td>
<td><strong>Piekuurtrein</strong> – rijdt tijdens de spitsuren als extra versterking.</td>
</tr>
<tr>
<td><strong>L</strong></td>
<td><strong>Lokale trein</strong> – stopt aan elk station langs het traject.</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td><strong>Stoptrein</strong> – bedient voorstedelijke gebieden en stopt frequent.</td>
</tr>
<tr>
<td><strong>INT</strong></td>
<td><strong>Internationale trein</strong> – klassieke grensoverschrijdende verbindingen.</td>
</tr>
<tr>
<td><strong>ICT</strong></td>
<td><strong>Toeristentrein</strong> – gericht op toeristische bestemmingen.</td>
</tr>
</tbody>
</table>
<p>Bron: <a href="https://nl.wikipedia.org/wiki/Lijst_van_treincategorie%C3%ABn_in_Belgi%C3%AB" target="_blank" rel="noopener noreferrer">Wikipedia</a></p>
<div class="observablehq observablehq--block"><!--:20c1d9be:--></div>
<div class="observablehq observablehq--block"><!--:4a96907f:--></div>
<p>Maar hoe vaak <strong>komt elk treintype voor</strong> in de dataset? Om daar een visueel beeld van te krijgen, gebruiken we een <strong>bubble chart</strong>.</p>
<div class="observablehq observablehq--block"><!--:1888641d:--></div>
<div class="observablehq observablehq--block"><!--:dd194582:--></div>
<div class="observablehq observablehq--block"><!--:b849ddfa:--></div>
<p>De visualisatie maakt meteen duidelijk dat sommige treintypes veel vaker voorkomen dan andere. Om die verschillen verder te onderzoeken, kijken we ook naar hoe de <strong>aanwezigheid van elk treintype doorheen de tijd evolueert</strong>.</p>
<div class="observablehq observablehq--block"><!--:57746480:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:4a6be801:--></div>
<p>Wat opvalt: slechts drie treintypes (<strong>IC, P, L</strong>) komen <strong>consistent</strong> voor in elk jaar van de dataset. Andere types, zoals <strong>ICT, INT en S</strong>, zijn maar gedurende een <strong>korte periode</strong> opgenomen. Dit kan een vertekend beeld geven van de algemene trends.</p>
<p>Daarom nemen we deze treintypes <strong>niet altijd mee</strong> in verdere vergelijkingen of verbanden. Zo houden we de analyses <strong>representatief</strong> en vermijden we <strong>foutieve conclusies</strong>.</p>
<h2 id="verdere-inzichten" tabindex="-1"><a class="observablehq-header-anchor" href="#verdere-inzichten">Verdere inzichten</a></h2>
<p>Wanneer we de <strong>stiptheid van de treinen</strong> door de jaren heen bekijken, kunnen we mogelijk trends ontdekken: is de situatie <strong>verbeterd</strong> of net <strong>verslechterd</strong>? Hieronder tonen we dat aan de hand van een <strong>interactieve line chart</strong>.</p>
<div class="observablehq observablehq--block"><!--:a3bdb986:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:e9262dea:--></div>
<p>Hoewel we niet voor elk treintype gegevens uit elk jaar hebben, springt één ding meteen in het oog: de <strong>INT-trein</strong> scoort het <strong>slechtst op stiptheid</strong>. Daarnaast blijft de <strong>algemene stiptheid</strong> doorheen de jaren <strong>vrij stabiel</strong> rond de <strong>90%</strong>, met hier en daar lichte schommelingen.</p>
<p>Om te onderzoeken of het <strong>seizoen invloed heeft op de vertragingen</strong>, visualiseren we per treintype de gemiddelde vertraging per seizoen.</p>
<div class="observablehq observablehq--block"><!--:f39c4b62:--></div>
<div class="observablehq observablehq--block"><!--:e60ecee4:--></div>
<p>De <strong>winterpiek</strong> bij <strong>ICT</strong> is ook te zien in de line chart hierboven over de stiptheid van de treinsoorten. In <strong>2022</strong> zie je een duidelijke daling in stiptheid naar 70%.</p>
<p>Op basis van al deze grafieken samen kunnen we echter <strong>geen duidelijk verband</strong> vaststellen tussen seizoen en vertraging.
Zo zien we geen algemene trend over al de treintypes heen. De variaties lijken eerder <strong>willekeurig dan seizoensgebonden</strong>.</p>
<p>Echter, als we ons beperken tot de 3 treintypes waarvoor we over alle jaren <strong>consistente data</strong> hebben, valt er wel iets interessants op.</p>
<div class="observablehq observablehq--block"><!--:230f30f6:--></div>
<div class="observablehq observablehq--block"><!--:e59ffbf5:--></div>
<p>Over het algemeen is er een <strong>seizoenspatroon</strong> in de gemiddelde vertraging te zien: de <strong>herfst</strong> kent de hoogste vertragingen, gevolgd door de <strong>winter</strong>, daarna de <strong>lente</strong>, en ten slotte de <strong>zomer</strong>, die het best scoort.
Bij de IC is de <strong>winter</strong> en <strong>lente</strong> echter wel gelijk aan elkaar, maar voor de rest klopt dit patroon wel.</p>
<p>Om te achterhalen of <strong>één bepaald treintype meer bijdraagt aan de totale vertragingen</strong> dan een andere, visualiseren we de gegevens in een <strong>boxplot</strong>. Deze grafiek geeft ons een <strong>gedetailleerd beeld van de spreiding en verdeling</strong> van vertragingen per treintype. Hier laten we opnieuw de treintypes weg die niet frequent voorkomen in de dataset.</p>
<div class="observablehq observablehq--block"><!--:754c0c8f:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:96e5af33:--></div>
<p>Voor extra duidelijkheid tonen we zowel <strong>relatieve</strong> als <strong>absolute cijfers</strong>:</p>
<ul>
<li>De <strong>relatieve vertragingen</strong> zijn gemiddelden, berekend door de totale vertraging te delen door het aantal gereden treinen.</li>
<li>De <strong>absolute vertragingen</strong> tonen het totaal aan vertraging per type, en geven zo weer hoe ernstig de impact kan zijn in omvang.</li>
</ul>
<p>Deze combinatie laat toe om niet alleen te zien <strong>hoe vaak treinen vertraging hebben</strong>, maar ook <strong>hoe zwaar die vertragingen doorwegen per treintype</strong>.</p>
<p>Uit de <strong>boxplot</strong> kunnen we halen dat de <strong>L</strong> trein gemiddeld beter doet dan de andere treinen — dit op basis van de 3 treintypes waarvoor we over <strong>alle jaren data</strong> hebben.
We zagen dat deze trein op de 2e plaats komt van de meest voorkomende treinsoorten en dus een representatieve trein is in de dataset. Dit duidt dus op de <strong>beste stiptheid</strong> van deze <strong>3 treintypes</strong> aan.</p>
<p>De <strong>IC-trein</strong>, die het vaakst voorkomt in de dataset, vertoont het <strong>meeste minuten absolute vertraging</strong>. Hoewel deze het meeste voorkomt, geeft deze trein dus de grootste impact op de totale vertragingen.</p>
<h2 id="conclusie" tabindex="-1"><a class="observablehq-header-anchor" href="#conclusie">Conclusie</a></h2>
<p>Hoewel er een licht patroon te zien is bij de <strong>seizoenen</strong>, kunnen we die niet veralgemenen voor alle treintypes. Ook zijn de verschillen tussen de seizoenen erg klein. Hier kunnen we dus <strong>niet veel uit besluiten</strong>.</p>
<p>Wanneer we kijken naar de <strong>3 treintypes</strong> waarvoor we over <strong>alle jaren data</strong> hebben, kunnen we wel iets besluiten. De <strong>L-trein</strong> vertoont <strong>gemiddeld de minste vertragingen</strong> en de <strong>IC-treinen</strong> zijn degene met het <strong>grootste aandeel aan vertragingen</strong>.</p>
<p>Kijken we daarentegen naar <strong>alle treinen</strong>, dan valt de <strong>INT-trein</strong> op als de <strong>minst stipte</strong>. Toch moeten we daar <strong>voorzichtig mee zijn</strong>: omdat er van de INT-trein geen data is over alle jaren, kunnen we daaruit <strong>geen conclusies trekken</strong>.</p>
<p>De onderstaande <strong>area chart</strong> toont duidelijk hoe de 3 treintypes doorheen de jaren het <strong>aandeel aan vertragingen</strong> hebben veroorzaakt.</p>
<div class="observablehq observablehq--block"><!--:a12436e4:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:e1b8cb7c:--></div>
</main>
<footer id="observablehq-footer">
<div>Gemaakt door Emma, Robin en Matthias</div>
</footer>
</div>
</body>
</html>
